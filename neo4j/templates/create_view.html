{% extends "base.html" %}
{% block content %}
<h2>Create View</h2>

<form method="post" action="{{ url_for('views.create') }}">
  <p>Name: <input name="name" required></p>
  <p>Build your query visually:</p>
  <div id="builder"></div>

  <!-- Hidden field für JSON -->
  <input type="hidden" name="query_json" id="query_json">
  <!-- Hidden field für Cypher -->
  <input type="hidden" name="cypher" id="cypher">

  <p><button type="submit">Save View</button></p>
</form>

<!-- jQuery + QueryBuilder von CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jQuery-QueryBuilder/dist/css/query-builder.default.min.css">
<script src="https://cdn.jsdelivr.net/npm/jQuery-QueryBuilder/dist/js/query-builder.standalone.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

<script>
  var filters = {{ filters|tojson }};
  const log = console.log;

  $('#builder').queryBuilder({
    plugins: ['bt-tooltip-errors'],
    filters: filters
  });

  function parse_rules () {
	  var rules = $('#builder').queryBuilder('getRules');
	  if (!$.isEmptyObject(rules)) {
		  $('#query_json').val(JSON.stringify(rules));
		  const cypher = toCypher(rules);
		  log(cypher);
		  $('#cypher').val(cypher);
	  }
  }

  $('form').on('submit', parse_rules);

function toCypher(rules) {
    // rekursiv die Regeln parsen
    function parseRule(rule) {
        if (rule.rules) {
            return '(' + rule.rules.map(parseRule).join(' ' + rule.condition + ' ') + ')';
        } else {
            // Feld: Label.prop oder nur prop
            let parts = rule.field.split('.');
            let label = parts.length > 1 ? parts[0].replace(/^:/,'').replace(/`/g,'') : null;
            let prop = parts.length > 1 ? parts[1] : parts[0];

            let op = rule.operator;
            let val = JSON.stringify(rule.value);

            let left = "n." + prop;

            switch(op) {
                case 'equal': return left + ' = ' + val;
                case 'not_equal': return left + ' <> ' + val;
                case 'contains': return "toString(" + left + ") CONTAINS " + val;
                case 'begins_with': return "toString(" + left + ") STARTS WITH " + val;
                case 'ends_with': return "toString(" + left + ") ENDS WITH " + val;
                default: return left + ' = ' + val;
            }
        }
    }

    let where = parseRule(rules);

    // Label aus erster Regel bestimmen
    let firstRule = rules.rules ? rules.rules[0] : rules;
    let label = "Entity"; // Default
    if (firstRule && firstRule.field) {
        let parts = firstRule.field.split('.');
        if (parts.length > 1) label = parts[0].replace(/^:/,'').replace(/`/g,'');
    }

    // Backticks nur bei Sonderzeichen nötig
    let labelStr = (/[^a-zA-Z0-9_]/.test(label)) ? "`" + label + "`" : label;

    let cypher = "MATCH (n:" + labelStr + ")";
    if (where && where.trim() !== "") cypher += " WHERE " + where;
    cypher += " RETURN n LIMIT 100";

    return cypher;
}



</script>
{% endblock %}
